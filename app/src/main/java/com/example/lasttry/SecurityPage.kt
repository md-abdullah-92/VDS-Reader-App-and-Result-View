package com.example.lasttry

import android.content.ClipData
import android.content.ClipboardManager
import android.content.ContentValues.TAG
import android.content.Context
import java.security.PrivateKey
import javax.crypto.Cipher
import android.util.Base64;
import android.util.Log
import android.widget.Toast
import java.nio.charset.StandardCharsets
import java.security.KeyFactory
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.NoSuchAlgorithmException
import java.security.PublicKey
import java.security.SecureRandom
import java.security.spec.InvalidKeySpecException
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.RSAPublicKeySpec
import java.security.spec.X509EncodedKeySpec


class SecurityPage {
    companion object {
       // var publicKey="MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAsSm7tserI8awN0nItgpHsRcnZ9JXxfcmfJzumsEKxDwlqqiirK475c52I1St8uVfX3Vo8Z276Q/4qH+bGQkVyMrvxoCzGVFq3aOq42HPntLmg3IGFGZMaK4CEsiuty07MUUwMVtyKQSTGm0wqyFfz/FEn7S1eXYJ1EnF7J+QYKEPCqaet9PVW8wLqKSJCdynR+0Pd58FIED1/K0DwG3sjLWZ0U78LBXR1iz2rBhD4jlMb7Exrgvw3eGXnqIJWDunConsMD160YqU6ZzsIrDDmAoWj5dgiHd85ArDJtbtk540Q5aOI/zyUPNB9nnwllgcVGx3A6MRmKZUWLAFiuy3HzzOMjKmc21u9O5o+XpWyBVauGtJPk6haFzDSBHHJT2VSqN2jtq4wvAv/TGTo5Cj5aG1eHRghZySxRUYzSgIQSiJ2DrHwE6GNidjGfoXHnlX3UInLRA+8G/4hr4wRO8uw46CC1u1vc1TwzkOl6T47ocYADwZY8BBdvoRFMoH+NjAQxjwYVzh6nYUJE4r261OfY0gvmXbPINswBFIfLGDqcqXNYOMXA8Haqjwum6vujAeAoxDvOG3ohqaur5jyFZOT6rn9B636Kuz6v0gFnHaUYNTvyYJELhTl36VmbHmjtMCs+eXiVurCfggIW5PLP4S8kmNNMQnRPtjg1Gy06JdRtsCAwEAAQ=="

        fun generateKeyPair(): KeyPair {
            try {
                // Initialize KeyPairGenerator with RSA algorithm
                val keyPairGenerator = KeyPairGenerator.getInstance("RSA")

                // Initialize with a secure random number generator
                val secureRandom = SecureRandom()
                keyPairGenerator.initialize(1024, secureRandom)

                // Generate key pair
                return keyPairGenerator.generateKeyPair()
            } catch (e: NoSuchAlgorithmException) {
                // Handle algorithm not supported exception
                throw RuntimeException("Algorithm not supported: RSA", e)
            }
        }

        fun copyToClipboard(context: Context, text: String) {
            // Get the clipboard system service
            val clipboardManager = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager

            // Create a ClipData object to hold the text
            val clipData = ClipData.newPlainText("text", text)

            // Set the ClipData on the clipboard
            clipboardManager.setPrimaryClip(clipData)
        }
        fun encryptData(data: ByteArray, publicKeyBase64: String): ByteArray {
            // Convert Base64 encoded public key to PublicKey object
            val publicKey: PublicKey = KeyFactory.getInstance("RSA")
                .generatePublic(X509EncodedKeySpec(Base64.decode(publicKeyBase64, Base64.DEFAULT)))

            // Initialize Cipher for encryption
            val cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding")
            cipher.init(Cipher.ENCRYPT_MODE, publicKey)

            // Perform encryption
            return cipher.doFinal(data)
        }
        fun decrypt(encryptedText: String, publicKey: PublicKey): String? {
            try {
                val cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding")
                cipher.init(Cipher.DECRYPT_MODE, publicKey)
                val decryptedBytes = cipher.doFinal(Base64.decode(encryptedText, Base64.DEFAULT))
                return String(decryptedBytes)
            } catch (e: Exception) {
                e.printStackTrace()
            }
            return null
        }
        private const val RSA_ALGORITHM = "RSA"
        private const val CIPHER_TYPE_FOR_RSA = "RSA/ECB/PKCS1Padding"

        private val keyFactory = KeyFactory.getInstance(RSA_ALGORITHM)
        private val cipher = Cipher.getInstance(CIPHER_TYPE_FOR_RSA)

        /**
         * Returns a PublicKey object from generated by String
         *
         * @param publicKeyString is PublicKey as a String
         * @throws IllegalArgumentException
         *
         * @throws java.security.InvalidKeyException
         * **/
        fun getPublicKeyFromString(publicKeyString: String): PublicKey? =
            try {
                val keySpec =
                    X509EncodedKeySpec(Base64.decode(publicKeyString.toByteArray(), Base64.DEFAULT))
                keyFactory.generatePublic(keySpec)
            } catch (exception: Exception) {
                exception.printStackTrace()
                null
            }

        /**
         * Returns a PrivateKey object from generated by String
         *
         * @param privateKeyString is PrivateKey as a String
         * @throws IllegalArgumentException
         *
         * @throws java.security.InvalidKeyException
         * **/
        fun getPrivateKeyFromString(privateKeyString: String): PrivateKey? =
            try {
                val keySpec =
                    PKCS8EncodedKeySpec(Base64.decode(privateKeyString.toByteArray(), Base64.DEFAULT))
                keyFactory.generatePrivate(keySpec)
            } catch (exception: Exception) {
                exception.printStackTrace()
                null
            }

        /**
         * Encrypts plain text and returns that encrypted text as String
         *
         * @param plainText is text to be encrypted
         * @param publicKey is a key for encryption
         * **/
        fun encryptText(plainText: String, publicKey: PublicKey): String? =
            try {
                cipher.init(Cipher.ENCRYPT_MODE, publicKey)
                Base64.encodeToString(cipher.doFinal(plainText.toByteArray()), Base64.DEFAULT)
            } catch (exception: Exception) {
                exception.printStackTrace()
                null
            }

        /**
         * Decrypt encrypted text and returns that plain text as String
         *
         * @param encryptedText is a encrypted text
         * @param privateKey is a key for decryption
         *
         * @throws javax.crypto.BadPaddingException
         * **/
        fun decryptText(encryptedText: String, privateKey: PrivateKey): String? =
            try {
                cipher.init(Cipher.DECRYPT_MODE, privateKey)
                String(cipher.doFinal(Base64.decode(encryptedText, Base64.DEFAULT)))
            } catch (exception: Exception) {
                exception.printStackTrace()
                null
            }

        fun differentiate(data: String,toastContext:Context): Map<String, Any> {
            fun parseInfo(data: String): Map<String, String> {
                val lines = data.trim().lines()
                val parsedData = mutableMapOf<String, String>()
                for (line in lines) {
                    val parts = line.split(":", limit = 2).map { it.trim() }
                    if (parts.size == 2) {
                        parsedData[parts[0]] = parts[1]
                    } else {
                        Toast.makeText(toastContext,"Invalid line format", Toast.LENGTH_LONG).show()
                        return parsedData
                    }
                }
                return parsedData
            }

            val sections = data.trim().split("\n\n")
            val result = mutableMapOf<String, Any>()
            for (section in sections) {
                val lines = section.trim().lines()
                if (lines.isNotEmpty()) {
                    val sectionType = lines[0].trim()
                    when (sectionType) {
                        //"PublicKey" -> result["PublicKey"] = lines.getOrNull(1)?.trim() ?: ""
                        "HashValue" -> result["HashValue"] = lines.getOrNull(1)?.trim() ?: ""
                        else -> {
                            if (sectionType.startsWith("Info")) {
                                val infoLines = lines.subList(1, lines.size)
                                val info = parseInfo(infoLines.joinToString("\n"))
                                result["Info"] = info
                            } else {
                                Toast.makeText(toastContext,"Unknown section type", Toast.LENGTH_LONG).show()
                            }
                        }
                    }
                }
            }
            return result
        }

    }

}

